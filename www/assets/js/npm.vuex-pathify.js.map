{"version":3,"sources":["webpack:///./node_modules/vuex-pathify/dist/vuex-pathify.esm.js"],"names":["__webpack_require__","d","__webpack_exports__","store","lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__","lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0___default","n","vuex","state","commit","dispatch","isPlainObject","value","isObject","Array","isArray","hasKey","obj","key","getKeys","map","String","Object","keys","match","getValue","path","every","valid","hasOwnProperty","setValue","create","split","reduce","index","length","hasValue","shift","resolver","options","mapping","strict","cache","deep","formatters","camel","args","len","arguments","text","replace","c","toUpperCase","join","snake","ref","this","apply","a","b","toLowerCase","const","members","getters","actions","mutations","resolvers","standard","type","name","formatters$$1","simple","resolveName","substr","fn","Error","resolve","modPath","trgName","absPath","statePath","objPath","includes","pop","_modulesNamespaceMap","module","target","get","member","resName","trgPath","exists","Payload","expr","makeSetter","action","mutation","makeGetter","stateOnly","getter","getValueIfEnabled","source","console","error","accessorize","set","setter","copy","concat","resolve$1","debug","log","plugin","prototype","update","assign","pathify","getStateKeys","makeGetters","makeMutations","makeActions","createDecorator"],"mappings":"oHAAAA,EAAAC,EAAAC,EAAA,sBAAAC,IAAA,IAAAC,EAAAJ,EAAA,QAAAK,EAAAL,EAAAM,EAAAF,GAQAG,EAAA,CAIAJ,MAAA,CACAK,MAAA,KAEAC,OAAA,WACU,GAKVC,SAAA,WACU,KA6BV,SAAAC,EAAAC,GACA,OAAAC,EAAAD,KAAAE,MAAAC,QAAAH,GASA,SAAAC,EAAAD,GACA,QAAAA,GAAA,kBAAAA,EAUA,SAAAI,EAAAC,EAAAC,GACA,OAAAL,EAAAI,IAAAC,KAAAD,EAeA,SAAAE,EAAAP,GACA,OAAAA,EAEAE,MAAAC,QAAAH,GACAA,EAAAQ,IAAA,SAAAF,GAAkC,OAAAG,OAAAH,KAClC,kBAAAN,EACAU,OAAAC,KAAAX,GACA,kBAAAA,GACAA,EAAAY,MAAA,YACA,GAPA,GAiBA,SAAAC,EAAAR,EAAAS,GACA,IAAAd,EAAAK,EACAM,EAAAJ,EAAAO,GAOA,OALAH,EAAAI,MAAA,SAAAT,GACA,IAAAU,EAAAjB,EAAAC,MAAAiB,eAAAX,GAEA,OADAN,EAAAgB,EAAAhB,EAAAM,QAAA,EACAU,IAEAhB,EAWA,SAAAkB,EAAAtB,EAAAkB,EAAAd,EAAAmB,QACA,IAAAA,OAAA,GAEA,IAAAR,EAAAG,EAAAM,MAAA,KACA,OAAAT,EAAAU,OAAA,SAAAhB,EAAAC,EAAAgB,GACA,IAAAjB,EACA,SAEA,GAAAiB,IAAAX,EAAAY,OAAA,EAEA,OADAlB,EAAAC,GAAAN,GACA,EAEA,IAAAC,EAAAI,EAAAC,YAAAD,GAAA,CACA,IAAAc,EAGA,SAFAd,EAAAC,GAAA,GAKA,OAAAD,EAAAC,IACGV,GAUH,SAAA4B,EAAAnB,EAAAS,GACA,IAAAH,EAAAJ,EAAAO,GACA,GAAAb,EAAAI,GAAA,CACA,MAAAM,EAAAY,OAAA,CACA,IAAAjB,EAAAK,EAAAc,QACA,IAAArB,EAAAC,EAAAC,GAGA,SAFAD,IAAAC,GAKA,SAEA,SAGA,IAyFAoB,EAzFAC,EAAA,CACAC,QAAA,WACAC,QAAA,EACAC,OAAA,EACAC,KAAA,GAGAC,EAAA,CACAC,MAAA,WACA,IAAAC,EAAA,GAAAC,EAAAC,UAAAb,OACA,MAAAY,IAAAD,EAAAC,GAAAC,UAAAD,GAEA,OAAAD,EAAAT,QAAAS,EACA1B,IAAA,SAAA6B,GAA4B,OAAAA,EAAAC,QAAA,cAAAC,GAAyC,OAAAA,EAAAC,kBACrEC,KAAA,KAGAC,MAAA,WACA,IAAAC,EAEAT,EAAA,GAAAC,EAAAC,UAAAb,OACA,MAAAY,IAAAD,EAAAC,GAAAC,UAAAD,GACA,OAAAQ,EAAAC,MACAX,MAAAY,MAAAF,EAAAT,GACAI,QAAA,2BAAA1B,EAAAkC,EAAAC,GAA0D,OAAAD,EAAA,IAAAC,IAC1DC,eAGAC,MAAA,WACA,IAAAN,EAEAT,EAAA,GAAAC,EAAAC,UAAAb,OACA,MAAAY,IAAAD,EAAAC,GAAAC,UAAAD,GACA,OAAAQ,EAAAC,MACAF,MAAAG,MAAAF,EAAAT,GACAM,gBAOAU,EAAA,CACAtD,MAAA,QACAuD,QAAA,UACAC,QAAA,WACAC,UAAA,cAMAC,EAAA,CAYAC,SAAA,SAAAC,EAAAC,EAAAC,GACA,OAAAF,GACA,gBACA,OAAAE,EAAAT,MAAA,MAAAQ,GACA,cACA,OAAAC,EAAAzB,MAAA,MAAAwB,GAEA,OAAAA,GAMAE,OAAA,SAAAH,EAAAC,EAAAC,GACA,kBAAAF,EACAE,EAAAzB,MAAA,MAAAwB,GAEAA,IAiBA,SAAAG,EAAAJ,EAAAC,GAEA,GAAAA,EAAA7C,MAAA,MACA,OAAA6C,EAAAI,OAAA,EAAAJ,EAAAlC,OAAA,GAIA,IAAAuC,EAAApC,EAGA,IAAAoC,EAAA,CACA,uBAAAnC,EAAAC,QACAkC,EAAAnC,EAAAC,aAIA,GADAkC,EAAAR,EAAA3B,EAAAC,UACAkC,EACA,UAAAC,MAAA,mCAAApC,EAAA,8CAAAjB,OAAAC,KAAA2C,GAAAb,KAAA,mDAIAf,EAAAoC,EAIA,OAAApC,EAAA8B,EAAAC,EAAAzB,GAUA,SAAAgC,EAAAzE,EAAAuB,GAEA,IAQAmD,EAAAC,EARAC,EAAArD,EAAAwB,QAAA,gBAGAK,EAAA7B,EAAAM,MAAA,KACAgD,EAAAzB,EAAA,GACA0B,EAAA1B,EAAA,GAIA,GAAAyB,EAAAE,SAAA,MACA,IAAA3D,EAAAyD,EAAAhD,MAAA,KACA8C,EAAAvD,EAAA4D,MACAN,EAAAtD,EAAA8B,KAAA,UAGAyB,EAAAE,EAIA,GAAAH,IAAA1E,EAAAiF,qBAAAP,EAAA,KACA,UAAAF,MAAA,kCAAAE,EAAA,eAAAnD,EAAA,KAIA,OACAqD,UACAM,OAAAR,EACAS,OAAAN,EACAX,KAAAS,EAAA5B,QAAA,QAQAqC,IAAA,SAAAnB,GAEA,IAAAoB,EAAArF,EAAA2D,EAAAM,IAGAqB,EAAAjB,EAAAJ,EAAAU,GAGAY,EAAAb,EACAA,EAAA,IAAAY,EACAA,EAGA,OACAE,OAAA,UAAAvB,EACAhC,EAAAoD,EAAAE,GACAA,KAAAF,EACAA,SACApB,KAAAsB,EACArB,KAAAoB,EACA/D,KAAAuD,KA2BA,IAAAW,EAAA,SAAAC,EAAAnE,EAAAd,GACA4C,KAAAqC,OACArC,KAAA9B,OACA8B,KAAA5C,SAoCA,SAAAkF,EAAA3F,EAAAuB,GACA,IAAAY,EAAAsC,EAAAzE,EAAAuB,GAEAqE,EAAAzD,EAAAiD,IAAA,WACA,GAAAQ,EAAAJ,OACA,gBAAA/E,GACA,OAAAT,EAAAO,SAAAqF,EAAA3B,KAAA2B,EAAArE,KACA,IAAAkE,EAAAlE,EAAAqE,EAAArE,KAAAd,GACAA,IAIA,IAAAoF,EAAA1D,EAAAiD,IAAA,aACA,OAAAS,EAAAL,OACA,SAAA/E,GACA,OAAAT,EAAAM,OAAAuF,EAAA5B,KAAA4B,EAAAtE,KACA,IAAAkE,EAAAlE,EAAAsE,EAAAtE,KAAAd,GACAA,IAQA,SAAAA,KAeA,SAAAqF,EAAA9F,EAAAuB,EAAAwE,GACA,IAGAC,EAHA7D,EAAAsC,EAAAzE,EAAAuB,GAIA,IAAAwE,IACAC,EAAA7D,EAAAiD,IAAA,WACAY,EAAAR,QACA,kBACA,IAAA/E,EAAAuF,EAAAX,OAAAW,EAAA/B,MACA,OAAA+B,EAAAzE,KACA0E,EAAA1E,EAAAd,EAAAuF,EAAAzE,MACAd,GAKA,IAAAJ,EAAA8B,EAAAiD,IAAA,SACA,OAAA/E,EAAAmF,OACA,WACA,OAAAS,EAAA1E,EAAAvB,EAAAK,MAAA8B,EAAAyC,UAQA,aAWA,SAAAqB,EAAAP,EAAAQ,EAAA3E,GACA,GAAAa,EAAAI,OAAAkD,EAAAX,SAAA,KAIA,OAAAzD,EAAA4E,EAAA3E,GAHA4E,QAAAC,MAAA,0DAAAV,EAAA,gDAMA,SAAAW,EAAArG,GASAA,EAAAsG,IAAA,SAAA/E,EAAAd,GACA,IAAA8F,EAAAZ,EAAA3F,EAAAuB,GACA,wBAAAgF,EACA,OAAAA,EAAA9F,IAWAT,EAAAoF,IAAA,SAAA7D,GACA,IAAAoB,EAAA,GAAAC,EAAAC,UAAAb,OAAA,EACA,MAAAY,KAAA,EAAAD,EAAAC,GAAAC,UAAAD,EAAA,GAEA,IAAAoD,EAAAF,EAAA9F,EAAAuB,GACA,wBAAAyE,EAAA,CACA,IAAAvF,EAAAuF,IACA,0BAAAvF,EACAA,EAAA6C,WAAA,EAAAX,GACAlC,IAWAT,EAAAwG,KAAA,SAAAjF,GACA,IAAAoB,EAAA,GAAAC,EAAAC,UAAAb,OAAA,EACA,MAAAY,KAAA,EAAAD,EAAAC,GAAAC,UAAAD,EAAA,GAEA,IAAAnC,EAAAT,EAAAoF,IAAA9B,MAAAtD,EAAA,CAAAuB,GAAAkF,OAAA9D,IACA,OAAAjC,EAAAD,GACQP,IAASO,GACjBA,GAIA,SAAAiG,EAAAzC,GACA,OAAAI,EAAAJ,EAAA,SAGA,SAAA0C,IACAR,QAAAS,IAAA,kEAAAxE,EAAAC,QAAA,SAAAD,EAAAC,SAAA,4EAAAqE,EAAA,6BAAAA,EAAA,+BAAAA,EAAA,+BAAAA,EAAA,gFAAAtE,EAAA,2BAAAA,EAAA,0BAAAA,EAAA,aAUA,SAAAyE,EAAA7G,GAGAI,EAAAJ,QAGAqG,EAAArG,GA/LAyF,EAAAqB,UAAAC,OAAA,SAAA5B,GACA,IAAA/C,EAAAI,KAEA,OADA2D,QAAAC,MAAA,0DAAA/C,KAAA,qDACA8B,EAGAxD,EAAAwD,EAAA9B,KAAA9B,KAAA8B,KAAA5C,MAAA2B,EAAAI,KAAA,GASA,OAAArB,OAAA6F,OAAA,GAAyB7B,IAmLzB,IAAA8B,EAAA,CACA7E,UACAyE,SACAF,SASA,SAAAO,EAAA7G,GACA,OAAAW,EAAA,oBAAAX,SAUA,SAAA8G,EAAA9G,GACA,OAAA6G,EAAA7G,GACAyB,OAAA,SAAAhB,EAAAC,GACA,IAAAiF,EAAA3B,EAAA,UAAAtD,GAIA,OAHAD,EAAAkF,GAAA,SAAA3F,GACA,OAAAA,EAAAU,IAEAD,GACK,IAQL,SAAAsG,EAAA/G,GACA,OAAA6G,EAAA7G,GACAyB,OAAA,SAAAhB,EAAAC,GACA,IAAA8E,EAAAxB,EAAA,YAAAtD,GAMA,OALAD,EAAA+E,GAAA,SAAAxF,EAAAI,GACAJ,EAAAU,GAAAN,aAAAgF,EACAhF,EAAAsG,OAAA1G,EAAAU,IACAN,GAEAK,GACK,IAQL,SAAAuG,EAAAhH,GACA,OAAA6G,EAAA7G,GACAyB,OAAA,SAAAhB,EAAAC,GACA,IAAA6E,EAAAvB,EAAA,UAAAtD,GACA8E,EAAAxB,EAAA,YAAAtD,GAMA,OALAD,EAAA8E,GAAA,SAAAxC,EAAA3C,GACA,IAAAH,EAAA8C,EAAA9C,OAEAA,EAAAuF,EAAApF,IAEAK,GACK,IAGL,IAAAd,EAAA,CACA4D,QAAAuD,EACArD,UAAAsD,EACAvD,QAAAwD,GA4YsBxH,EAAQ,QAAqByH,gBAiEpCvH,EAAA","file":"assets/js/npm.vuex-pathify.js","sourcesContent":["/**\n * Bundle of: vuex-pathify\n * Generated: 2019-04-08\n * Version: 1.2.1\n */\n\nimport cloneDeep from 'lodash.clonedeep';\n\nvar vuex = {\n  /**\n   * THIS OBJECT IS REPLACED AT RUNTIME WITH THE ACTUAL VUEX STORE\n   */\n  store: {\n    state: null,\n\n    commit: function commit () {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('[Vuex Pathify] Plugin not initialized!');\n      }\n    },\n\n    dispatch: function dispatch () {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('[Vuex Pathify] Plugin not initialized!');\n      }\n    }\n  }\n};\n\nfunction commit() {\n  var ref;\n\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n  (ref = vuex.store).commit.apply(ref, args);\n}\n\nfunction dispatch() {\n  var ref;\n\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = vuex.store).dispatch.apply(ref, args)\n}\n\n/**\n * Tests whether a passed value is an Object\n *\n * @param   {*}       value   The value to be assessed\n * @returns {boolean}         Whether the value is a true Object\n */\nfunction isPlainObject (value) {\n  return isObject(value) && !Array.isArray(value)\n}\n\n/**\n * Tests whether a passed value is an Object or Array\n *\n * @param   {*}       value   The value to be assessed\n * @returns {boolean}         Whether the value is an Object or Array\n */\nfunction isObject (value) {\n  return !!value && typeof value === 'object'\n}\n\n/**\n * Tests whether a passed value is an Object and has the specified key\n *\n * @param   {Object}   obj    The source object\n * @param   {string}   key    The key to check that exists\n * @returns {boolean}         Whether the predicate is satisfied\n */\nfunction hasKey(obj, key) {\n  return isObject(obj) && key in obj\n}\n\n/**\n * Gets an array of keys from a value\n *\n * The function handles various types:\n *\n * - string - match all words\n * - object - return keys\n * - array  - return a string array of its values\n *\n * @param   {*}       value   The value to get keys from\n * @returns {Array}\n */\nfunction getKeys (value) {\n  return !value\n    ? []\n    : Array.isArray(value)\n      ? value.map(function (key) { return String(key); })\n      : typeof value === 'object'\n        ? Object.keys(value)\n        : typeof value === 'string'\n          ? value.match(/[$\\w]+/g) || []\n          : []\n}\n\n/**\n * Gets a value from an object, based on a path to the property\n *\n * @param   {Object}                obj     The Object to get the value from\n * @param   {string|Array|Object}  [path]   The optional path to a sub-property\n * @returns {*}\n */\nfunction getValue (obj, path) {\n  var value = obj;\n  var keys = getKeys(path);\n\n  keys.every(function (key) {\n    var valid = isPlainObject(value) && value.hasOwnProperty(key);\n    value = valid ? value[key] : void 0;\n    return valid\n  });\n  return value\n}\n\n/**\n * Sets a value on an object, based on a path to the property\n *\n * @param   {Object}                obj     The Object to set the value on\n * @param   {string|Array|Object}   path    The path to a sub-property\n * @param   {*}                     value   The value to set\n * @returns {Boolean}                       True or false, depending if value was set\n */\nfunction setValue (state, path, value, create) {\n  if ( create === void 0 ) create = false;\n\n  var keys = path.split('.');\n  return keys.reduce(function (obj, key, index)  {\n    if (!obj) {\n      return false\n    }\n    else if (index === keys.length - 1) {\n      obj[key] = value;\n      return true\n    }\n    else if (!isObject(obj[key]) || !(key in obj)) {\n      if (create) {\n        obj[key] = {};\n      } else {\n        return false\n      }\n    }\n    return obj[key]\n  }, state)\n}\n\n/**\n * Checks an object has a property, based on a path to the property\n *\n * @param   {Object}                obj     The Object to check the value on\n * @param   {string|Array|Object}   path    The path to a sub-property\n * @returns {boolean}                       Boolean true or false\n */\nfunction hasValue(obj, path) {\n  var keys = getKeys(path);\n  if (isObject(obj)) {\n    while (keys.length) {\n      var key = keys.shift();\n      if (hasKey(obj, key)) {\n        obj = obj[key];\n      } else {\n        return false\n      }\n    }\n    return true\n  }\n  return false\n}\n\nvar options = {\n  mapping: 'standard',  // map states to store members using the \"standard\" scheme\n  strict: true,         // throw an error if the store member cannot be found\n  cache: true,          // cache generated functions for faster re-use\n  deep: 1,              // allow sub-property access, but not creation\n};\n\nvar formatters = {\n  camel: function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.shift() + args\n      .map(function (text) { return text.replace(/\\w/, function (c) { return c.toUpperCase(); }); })\n      .join('')\n  },\n\n  snake: function () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n    return (ref = this)\n      .camel.apply(ref, args)\n      .replace(/([a-z])([A-Z])/g, function (match, a, b) { return a + '_' + b; })\n      .toLowerCase()\n  },\n\n  const: function () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n    return (ref = this)\n      .snake.apply(ref, args)\n      .toUpperCase()\n  }\n};\n\n/**\n * Map of store members\n */\nvar members = {\n  state: 'state',\n  getters: 'getters',\n  actions: '_actions',\n  mutations: '_mutations',\n};\n\n/**\n * Map of default resolver functions\n */\nvar resolvers = {\n\n  /**\n   * Standard name mapping function\n   *\n   * Adheres to seemingly the most common Vuex naming pattern\n   *\n   * @param   {string}  type          The member type, i.e state, getters, mutations, or actions\n   * @param   {string}  name          The name of the property being targeted, i.e. value\n   * @param   {object}  formatters    A formatters object with common format functions, camel, snake, const\n   * @returns {string}\n   */\n  standard: function standard (type, name, formatters$$1) {\n    switch(type) {\n      case 'mutations':\n        return formatters$$1.const('set', name) // SET_BAR\n      case 'actions':\n        return formatters$$1.camel('set', name) // setBar\n    }\n    return name // bar\n  },\n\n  /**\n   * Simple name mapping function\n   */\n  simple: function simple (type, name, formatters$$1) {\n    if (type === 'actions') {\n      return formatters$$1.camel('set', name) // setBar\n    }\n    return name // bar\n  },\n\n};\n\n/**\n * Configured resolver\n */\nvar resolver;\n\n/**\n * Internal function to resolve member name using configured mapping function\n *\n * @param   {string}  type  The member type, i.e. actions\n * @param   {string}  name  The supplied path member id, i.e. value\n * @returns {string}        The resolved member name, i.e. SET_VALUE\n */\nfunction resolveName (type, name) {\n  // bypass resolver\n  if (name.match(/!$/)) {\n    return name.substr(0, name.length - 1)\n  }\n\n  // configured resolver\n  var fn = resolver;\n\n  // unconfigured resolver! (runs once)\n  if (!fn) {\n    if (typeof options.mapping === 'function') {\n      fn = options.mapping;\n    }\n    else {\n      fn = resolvers[options.mapping];\n      if (!fn) {\n        throw new Error((\"[Vuex Pathify] Unknown mapping '\" + (options.mapping) + \"' in options\\n    - Choose one of '\" + (Object.keys(resolvers).join(\"', '\")) + \"'\\n    - Or, supply a custom function\\n\"))\n      }\n    }\n\n    resolver = fn;\n  }\n\n  // resolve!\n  return resolver(type, name, formatters)\n}\n\n/**\n * Creates a resolver object that caches properties and can resolve store member properties\n *\n * @param   {object}  store     The Vuex store instance\n * @param   {string}  path      A pathify path to the store target, i.e. 'foo/bar@a.b.c'\n * @returns {object}\n */\nfunction resolve (store, path) {\n  // state\n  var absPath = path.replace(/[/@!]+/g, '.');\n\n  // paths\n  var ref = path.split('@');\n  var statePath = ref[0];\n  var objPath = ref[1];\n\n  // parent\n  var modPath, trgName;\n  if (statePath.includes('/')) {\n    var keys = statePath.split('/');\n    trgName = keys.pop();\n    modPath = keys.join('/');\n  }\n  else {\n    trgName = statePath;\n  }\n\n  // throw error if module does not exist\n  if (modPath && !store._modulesNamespaceMap[modPath + '/']) {\n    throw new Error((\"[Vuex Pathify] Unknown module '\" + modPath + \"' via path '\" + path + \"'\"))\n  }\n\n  // resolve targets\n  return {\n    absPath: absPath,\n    module: modPath,\n    target: statePath,\n    name: trgName.replace('!', ''),\n\n    /**\n     * Returns properties about the targeted member\n     *\n     * @param   {string}  type  The member type, i.e state, getters, mutations, or actions\n     * @returns {{exists: boolean, member: object, type: string, path: string}}\n     */\n    get: function (type) {\n      // targeted member, i.e. store._getters\n      var member = store[members[type]];\n\n      // resolved target name, i.e. SET_VALUE\n      var resName = resolveName(type, trgName);\n\n      // target path, i.e. store._getters['module/SET_VALUE']\n      var trgPath = modPath\n        ? modPath + '/' + resName\n        : resName;\n\n      // return values\n      return {\n        exists: type === 'state'\n          ? hasValue(member, trgPath)\n          : trgPath in member,\n        member: member,\n        type: trgPath,\n        name: resName,\n        path: objPath,\n      }\n    }\n  }\n}\n\n/**\n * Error generation function for accessors\n */\nfunction getError(path, resolver, aName, a, bName, b) {\n  var error = \"[Vuex Pathify] Unable to map path '\" + path + \"':\";\n  if (path.includes('!')) {\n    error += \"\\n    - Did not find \" + aName + \" or \" + bName + \" named '\" + (resolver.name) + \"' on \" + (resolver.module ? (\"module '\" + (resolver.module) + \"'\"): 'root store');\n  }\n  else {\n    var aText = a\n      ? (aName + \" '\" + (a.name) + \"' or \")\n      : '';\n    var bText = bName + \" '\" + (b.name) + \"'\";\n    error += \"\\n    - Did not find \" + aText + bText + \" on \" + (resolver.module ? (\"module '\" + (resolver.module) + \"'\"): 'store') + \"\\n    - Use direct syntax '\" + (resolver.target.replace(/(@|$)/, '!$1')) + \"' (if member exists) to target directly\";\n  }\n  return error\n}\n\n/**\n * Handles passing and setting of sub-property values\n */\nvar Payload = function Payload (expr, path, value) {\n  this.expr = expr;\n  this.path = path;\n  this.value = value;\n};\n\n/**\n * Set sub-property on target\n * @param target\n */\nPayload.prototype.update = function update (target) {\n  if (!options.deep) {\n    console.error((\"[Vuex Pathify] Unable to access sub-property for path '\" + (this.expr) + \"':\\n    - Set option 'deep' to 1 to allow it\"));\n    return target\n  }\n\n  var success = setValue(target, this.path, this.value, options.deep > 1);\n\n  // unable to set sub-property\n  if (!success && process.env.NODE_ENV !== 'production') {\n    console.error((\"[Vuex Pathify] Unable to create sub-property for path '\" + (this.expr) + \"':\\n    - Set option 'deep' to 2 to allow it\"));\n    return target\n  }\n\n  // set sub-property\n  return Object.assign({}, target)\n};\n\n/**\n * Creates a setter function for the store, automatically targeting actions or mutations\n *\n * Also supports setting of sub-properties as part of the path\n *\n * @see documentation for more detail\n *\n * @param   {Object}  store   The store object\n * @param   {string}  path    The path to the target node\n * @returns {*|Promise}       The return value from the commit() or dispatch()\n */\nfunction makeSetter (store, path) {\n  var resolver = resolve(store, path);\n\n  var action = resolver.get('actions');\n  if (action.exists) {\n    return function (value) {\n      return store.dispatch(action.type, action.path\n        ? new Payload(path, action.path, value)\n        : value)\n    }\n  }\n\n  var mutation = resolver.get('mutations');\n  if (mutation.exists) {\n    return function (value) {\n      return store.commit(mutation.type, mutation.path\n        ? new Payload(path, mutation.path, value)\n        : value)\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(getError(path, resolver, 'action', action, 'mutation', mutation));\n  }\n\n  return function (value) {}\n}\n\n/**\n * Creates a getter function for the store, automatically targeting getters or state\n *\n * Also supports returning of sub-properties as part of the path\n *\n * @see documentation for more detail\n *\n * @param   {Object}    store       The store object\n * @param   {string}    path        The path to the target node\n * @param   {boolean}  [stateOnly]  An optional flag to get from state only (used when syncing)\n * @returns {*|Function}            The state value or getter function\n */\nfunction makeGetter (store, path, stateOnly) {\n  var resolver = resolve(store, path);\n\n  // for sync, we don't want to read only from state\n  var getter;\n  if (!stateOnly) {\n    getter = resolver.get('getters');\n    if (getter.exists) {\n      return function () {\n        var value = getter.member[getter.type];\n        return getter.path\n          ? getValueIfEnabled(path, value, getter.path)\n          : value\n      }\n    }\n  }\n\n  var state = resolver.get('state');\n  if (state.exists) {\n    return function () {\n      return getValueIfEnabled(path, store.state, resolver.absPath)\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(getError(path, resolver, 'getter', getter, 'state', state));\n  }\n\n  return function () {}\n}\n\n/**\n * Utility function to get value from store, but only if options allow\n *\n * @param   {string}  expr    The full path expression\n * @param   {object}  source  The source object to get property from\n * @param   {string}  path    The full dot-path on the source object\n * @returns {*}\n */\nfunction getValueIfEnabled(expr, source, path) {\n  if (!options.deep && expr.includes('@')) {\n    console.error((\"[Vuex Pathify] Unable to access sub-property for path '\" + expr + \"':\\n    - Set option 'deep' to 1 to allow it\"));\n    return\n  }\n  return getValue(source, path)\n}\n\nfunction accessorize (store) {\n\n  /**\n   * Set a property on the store, automatically using actions or mutations\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             value   The value to set\n   * @returns {Promise|*}             Any return value from the action / commit\n   */\n  store.set = function (path, value) {\n    var setter = makeSetter(store, path);\n    if (typeof setter !== 'undefined') {\n      return setter(value)\n    }\n  };\n\n  /**\n   * Get a property from the store, automatically using getters or state\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             args    Optional getter function parameters\n   * @returns {*|undefined}           The state value / getter value / getter function / or undefined\n   */\n  store.get = function (path) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var getter = makeGetter(store, path);\n    if (typeof getter !== 'undefined') {\n      var value = getter();\n      return typeof value === 'function'\n        ? value.apply(void 0, args)\n        : value\n    }\n  };\n\n  /**\n   * Set a property on the store, automatically using actions or mutations\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             args    Optional getter function parameters\n   * @returns {*|undefined}           The value, or undefined\n   */\n  store.copy = function (path) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var value = store.get.apply(store, [ path ].concat( args ));\n    return isObject(value)\n      ? cloneDeep(value)\n      : value\n  };\n}\n\nfunction resolve$1 (type) {\n  return resolveName(type, 'value')\n}\n\nfunction debug () {\n  console.log((\"\\n  [Vuex Pathify] Options:\\n\\n  Mapping (\" + (typeof options.mapping === 'function' ? 'custom' : options.mapping) + \")\\n-------------------------------\\n  path       : value\\n  state      : \" + (resolve$1('state')) + \"\\n  getters    : \" + (resolve$1('getters')) + \"\\n  actions    : \" + (resolve$1('actions')) + \"\\n  mutations  : \" + (resolve$1('mutations')) + \"\\n\\n  Settings\\n-------------------------------\\n  strict     : \" + (options.strict) + \"\\n  cache      : \" + (options.cache) + \"\\n  deep       : \" + (options.deep) + \"\\n\\n\"));\n}\n\n// plugin\n\n/**\n * Store plugin which updates the store object with set() and get() methods\n *\n * @param {Object} store  The store object\n */\nfunction plugin (store) {\n\n  // cache store instance\n  vuex.store = store;\n\n  // add pathify accessors\n  accessorize(store);\n}\n\nvar pathify = {\n  options: options,\n  plugin: plugin,\n  debug: debug,\n};\n\n/**\n * Utility function to grab keys for state\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n * @returns {Array}\n */\nfunction getStateKeys (state) {\n  return getKeys(typeof state === 'function' ? state() : state)\n}\n\n/**\n * Helper function to mass-create default getter functions for an existing state object\n *\n * Note that you don't need to create top-level getter functions if using $store.get(...)\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeGetters (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var getter = resolveName('getters', key);\n      obj[getter] = function (state) {\n        return state[key]\n      };\n      return obj\n    }, {})\n}\n\n/**\n * Helper function to mass-create default mutation functions for an existing state object\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeMutations (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var mutation = resolveName('mutations', key);\n      obj[mutation] = function (state, value) {\n        state[key] = value instanceof Payload\n          ? value.update(state[key])\n          : value;\n      };\n      return obj\n    }, {})\n}\n\n/**\n * Helper function to mass-create default actions functions for an existing state object\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeActions (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var action = resolveName('actions', key);\n      var mutation = resolveName('mutations', key);\n      obj[action] = function (ref, value) {\n        var commit = ref.commit;\n\n        commit(mutation, value);\n      };\n      return obj\n    }, {})\n}\n\nvar store = {\n  getters: makeGetters,\n  mutations: makeMutations,\n  actions: makeActions,\n};\n\n// -------------------------------------------------------------------------------------------------------------------\n// external\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Utility function to expand wildcard path for get()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        state       state hash\n * @param   {object}        getters     getters hash\n * @returns {array|string}\n */\nfunction expandGet (path, state, getters) {\n  if (!init(path, state)) {\n    return ''\n  }\n  return resolveStates(path, state).concat( resolveHandlers(path, getters) )\n}\n\n/**\n * Utility function to expand wildcard path for sync()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        state       state hash\n * @returns {array|string}\n */\nfunction expandSync (path, state) {\n  if (!init(path, state)) {\n    return ''\n  }\n  return resolveStates(path, state)\n}\n\n/**\n * Utility function to expand wildcard path for actions()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        actions     actions hash\n * @returns {array|string}\n */\nfunction expandCall (path, actions) {\n  if (!init(path, actions)) {\n    return ''\n  }\n  return resolveHandlers(path, actions)\n}\n\n\n// -------------------------------------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Helper function to resolve state properties from a wildcard path\n *\n * Note: this function traverses into the state object and any properties / sub-properties\n *\n * @param   {string}    path    A path with a wildcard at the end\n * @param   {object}    state   A state object on which to look up the sub-properties\n * @returns {string[]}          An array of paths\n */\nfunction resolveStates (path, state) {\n  // grab segments\n  var last = path.match(/([^/@\\.]+)$/)[1];\n  var main = path.substring(0, path.length - last.length);\n  var keys = main.replace(/\\W+$/, '').split(/[/@.]/);\n\n  // find state parent\n  var obj = main\n    ? getValue(state, keys)\n    : state;\n  if (!obj) {\n    console.error((\"[Vuex Pathify] Unable to expand wildcard path '\" + path + \"':\\n    - It looks like '\" + (main.replace(/\\W+$/, '')) + \"' does not resolve to an existing state property\"));\n    return []\n  }\n\n  // filter children\n  var rx = new RegExp('^' + last.replace(/\\*/g, '\\\\w+') + '$');\n  return Object\n    .keys(obj)\n    .filter(function (key) { return rx.test(key); })\n    .map(function (key) { return main + key; })\n}\n\n/**\n * Helper function to resolve getters, actions or mutations from a wildcard path\n *\n * Note: this function filters the top-level flat hash of members\n *\n * @param   {string}    path      A path with a wildcard at the end\n * @param   {object}    hash      A hash on which to filter by key => wildcard\n * @returns {string[]}            An array of paths\n */\nfunction resolveHandlers (path, hash) {\n  var rx = new RegExp('^' + path.replace(/\\*/g, '\\\\w+') + '$');\n  return Object.keys(hash).filter(function (key) { return rx.test(key); })\n}\n\n\n// -------------------------------------------------------------------------------------------------------------------\n// utility\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Pre-flight check for wildcard paths\n *\n * @param   {string}  path\n * @param   {object}  state\n * @returns {boolean}\n */\nfunction init (path, state) {\n  // only wildcards in final path segment are supported\n  if (path.includes('*') && /\\*.*[/@.]/.test(path)) {\n    console.error((\"[Vuex Pathify] Invalid wildcard placement for path '\" + path + \"':\\n    - Wildcards may only be used in the last segment of a path\"));\n    return false\n  }\n\n  // edge case where store sometimes doesn't exist\n  if (!state) {\n    console.error((\"[Vuex Pathify] Unable to expand wildcard path '\" + path + \"':\\n    - The usual reason for this is that the router was set up before the store\\n    - Make sure the store is imported before the router, then reload\"));\n    return false\n  }\n\n  return true\n}\n\n/**\n * Helper function to convert Pathify path syntax paths to objects\n *\n * Handles:\n *\n * - string path\n * - object and array formats\n * - path + object/array format\n * - wildcards in path\n *\n * Returns a single string, or hash of key => paths\n *\n * @param   {string|object|array}  [path]       An optional path prefix\n * @param   {object}                props       An optional hash or array of paths / segments\n * @param   {function}              fnResolver  A function to resolve wildcards\n * @returns {object|string}\n */\nfunction makePaths (path, props, fnResolver) {\n  // handle wildcards\n  if (typeof path === 'string' && path.includes('*')) {\n    return makePathsHash(fnResolver(path))\n  }\n\n  // handle array as path\n  if (Array.isArray(path)) {\n    return makePathsHash(path)\n  }\n\n  // handle object as path\n  if (isObject(path)) {\n    props = path;\n    path = '';\n  }\n\n  // if props is an array\n  if (Array.isArray(props)) {\n    var paths = props\n      .map(function (prop) {\n        return makePath(path, prop)\n      });\n    return makePathsHash(paths)\n  }\n\n  // if props is an object\n  if (isObject(props)) {\n    return Object\n      .keys(props)\n      .reduce(function (paths, key) {\n        paths[key] = makePath(path, props[key]);\n        return paths\n      }, {})\n  }\n\n  // if path is a single string without wildcards\n  return path\n}\n\n/**\n * Helper function to concatenate two path components into a valid path\n *\n * Handles one or no \"/\" \"@\" or '.' characters in either string\n *\n * @param   {string}  path\n * @param   {string}  target\n * @returns {string}\n */\nfunction makePath (path, target) {\n  if ( target === void 0 ) target = '';\n\n  path = path.replace(/\\/+$/, '');\n  var value = path.includes('@')\n    ? path + '.' + target\n    : path + '/' + target;\n  return value\n    .replace(/^\\/|[.@/]+$/, '')\n    .replace(/\\/@/, '@')\n    .replace(/@\\./, '@')\n}\n\n/**\n * Helper function to convert an array of paths to a hash\n *\n * Uses the last path segment as the key\n *\n * @param   {string[]}  paths   An array of paths to convert to a hash\n * @returns {object}            A hash of paths\n */\nfunction makePathsHash (paths) {\n  return paths.reduce(function (paths, path) {\n    var key = path.match(/\\w+$/);\n    paths[key] = path;\n    return paths\n  }, {})\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// entry\n// -------------------------------------------------------------------------------------------------------------------\n\nfunction get (path, props) {\n  return make(path, props, getOne, function (path) {\n    return expandGet(path, vuex.store.state, vuex.store.getters)\n  })\n}\n\nfunction sync (path, props) {\n  return make(path, props, syncOne, function (path) {\n    return expandSync(path, vuex.store.state)\n  })\n}\n\nfunction call (path, props) {\n  return make(path, props, callOne, function (path) {\n    return expandCall(path, vuex.store._actions)\n  })\n}\n\n\n// -------------------------------------------------------------------------------------------------------------------\n// utility\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Creates multiple 2-way vue:vuex computed properties\n *\n * The function has multiple usages:\n *\n *  1. multiple properties from multiple modules\n *\n *     - @usage                                 ...sync({foo: 'module1/foo', bar: 'module2/bar'})\n *\n *     - @param   {Object}          props       a hash of key:path state/getter or commit/action references\n *\n *  2. multiple properties from a single module (object shorthand)\n *\n *     - @usage                                 ...sync('module', {foo: 'foo', bar: 'bar'})\n *\n *     - @param   {string}          path        a path to a module\n *     - @param   {Object}          props       a hash of key:prop state/getter or commit/action references\n *\n *  3. multiple properties from a single module (array shorthand)\n *\n *     - @usage                                 ...sync('module', ['foo', 'bar'])\n *\n *     - @param   {string}          path        a path to a module\n *     - @param   {Array}           props       an Array of state/getter or commit/action references\n *\n * Where different getter / setters need to be specified, pass getter and setter in\n * the same string, separating with a | character:\n *\n *     - @usage                                 ...sync('module', ['foo|updateFoo'])\n *\n * @param   {string|Object}         path        a path to a module, or a hash of state/getter or commit/action references\n * @param   {Object|Array}          props       a hash of state/getter or commit/action references\n * @param   {Function}              fnHandler   a callback function to create the handler\n * @param   {Function}              fnResolver\n * @returns {{set, get}}                        a hash of Objects\n */\nfunction make (path, props, fnHandler, fnResolver) {\n  // expand path / props\n  var data = makePaths(path, props, fnResolver);\n\n  // handle single paths\n  if (typeof data === 'string') {\n    return fnHandler(data)\n  }\n\n  // handle multiple properties\n  Object\n    .keys(data)\n    .forEach(function (key) {\n      data[key] = fnHandler(data[key]);\n    });\n  return data\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// one\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Creates a single 2-way vue:vuex computed property\n *\n * @param   {string}      path      a path to a state/getter reference. Path can contain an optional commit / action reference, separated by a |, i.e. foo/bar|updateBar\n * @returns {Object}                a single get/set Object\n */\nfunction syncOne (path) {\n  var ref = path.split('|');\n  var getter = ref[0];\n  var setter = ref[1];\n  if (setter) {\n    setter = getter.replace(/\\w+!?$/, setter.replace('!', '') + '!');\n  }\n  return getter && setter\n    ? { get: getOne(getter, true), set: setOne(setter) }\n    : { get: getOne(getter, true), set: setOne(getter) }\n}\n\n/**\n * Creates a single 1-way vue:vuex computed getter\n *\n * @param   {string}      path          A path to a state/getter reference\n * @param   {boolean}    [stateOnly]    An optional flag to get from state only (used when syncing)\n * @returns {Object}                    A single getter function\n */\nfunction getOne (path, stateOnly) {\n  var getter;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (!this.$store) {\n      throw new Error('[Vuex Pathify] Unexpected condition: this.$store is undefined.\\n\\nThis is a known edge case with some setups and will cause future lookups to fail')\n    }\n    if (!getter) {\n      getter = makeGetter(this.$store, path, stateOnly);\n    }\n    return getter.apply(void 0, args)\n  }\n}\n\n/**\n * Creates a single 1-way vue:vuex setter\n *\n * @param   {string}      path      a path to an action/commit reference\n * @returns {Function}              a single setter function\n */\nfunction setOne (path) {\n  var setter;\n  return function (value) {\n    var this$1 = this;\n\n    if (!setter) {\n      setter = makeSetter(this.$store, path);\n    }\n    this.$nextTick(function () { return this$1.$emit('sync', path, value); });\n    return setter(value)\n  }\n}\n\n/**\n * Creates a single action dispatcher\n *\n * @param   {string}      path      a path to an action/commit reference\n * @returns {Function}              a single setter function\n */\nfunction callOne (path) {\n  return function (value) {\n    return this.$store.dispatch(path, value)\n  }\n}\n\n/**\n * @module\n * @description Decorators for Vuex Pathify component helpers.\n * \n * For example:\n * ```js\n * @Component\n * class MyComponent extends Vue {\n *   @Get(\"name\")\n *   @Set(\"name\")\n *   @Call(\"setName\")\n * }\n * ```\n */\n\nvar createDecorator = require('vue-class-component').createDecorator;\n\n/**\n * Decortaor for `get` component helper.\n * @param   {string}          path - Path in store\n * @returns {VueDecorator}         - Vue decortaor to be used in cue class component.\n */\nfunction Get(path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.computed) { options.computed = {}; }\n    options.computed[key] = get(path);\n  })\n}\n\n/**\n * Decortaor for `sync` component helper.\n * @param   {string}          path - Path in store\n * @returns {VueDecorator}         - Vue decortaor to be used in cue class component.\n */\nfunction Sync(path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.computed) { options.computed = {}; }\n    options.computed[key] = sync(path);\n  })\n}\n\n/**\n * Decortaor for `call` component helper.\n * @param   {string}          path - Path in store\n * @returns {VueDecorator}  - Vue decortaor to be used in cue class component.\n */\nfunction Call(path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.methods) { options.methods = {}; }\n    options.methods[key] = call(path);\n  })\n}\n\n/**\n * Helper function to generate a mixin that registers module and computed properties on component creation\n *\n * @param   {string|Array}  path        The path to register the Vuex module on\n * @param   {object}        module      The module definition to register when the\n * @param   {function}      callback    A callback returning store members to be added to the component definition\n * @param   {object}       [options]    Optional Vuex module registration options\n * @returns {object}                    The mixin\n */\nfunction registerModule(path, module, callback, options) {\n  return {\n    beforeCreate: function beforeCreate () {\n      this.$store.registerModule(path, module, options);\n      var members = callback();\n      this.$options.computed = Object.assign(this.$options.computed || {}, members.computed || {});\n      this.$options.methods = Object.assign(this.$options.methods || {}, members.methods || {});\n    },\n\n    destoyed: function destoyed () {\n      this.$store.unregisterModule(path);\n    }\n  }\n}\n\nexport default pathify;\nexport { store as make, Payload, get, sync, call, Get, Sync, Call, commit, dispatch, registerModule };\n"],"sourceRoot":""}